# SM4 优化方案对比

## 一、SM4简介
- **分组长度**：128位（16字节/4字）  
- **密钥长度**：128位（16字节/4字）  
- **加解密机制**：32轮迭代，每轮需轮密钥（类似DES/AES）

---

## 二、文件结构
| 文件               | 功能描述                                                                 |
|--------------------|--------------------------------------------------------------------------|
| `Sm4.cpp`          | 标准参考实现，含基础功能与性能测试                                      |
| `Sm4_t_table.cpp`  | 基于查表（T-Table）优化实现                                             |
| `Sm4_aesni.cpp`    | 使用AESNI指令集优化，并行处理4组SM4                                     |
| `Sm4.h`            | 基础SM4头文件                                                           |
| `Sm4aesni.h`       | AESNI指令优化的头文件                                                   |

---

## 三、性能对比
| 对比方案 | 加密耗时 (cycles/block) | 解密耗时 (cycles/block) |
|---------------|-------------------------|-------------------------|
| 原始SM4       | 750.55                  | 840.03                  |
| T-Table优化   | 492.78 (34.3%)         | 515.44 (38.6%)         |
| AESNI优化     | **129.44 (82.7%)**     | **130.96 (84.4%)**     |

---

## 四、优化技术详解

### 1. T-Table优化
- **核心思想**：预计算合并S盒与线性变换L  
- **实现方式**：将4个8-bit S盒替换为32-bit输入/输出的T表 。提前计算所有可能结果，运行时直接查表  
- **优势**：减少实时计算开销，提升查表效率  

## 2. AES-NI 优化实现

### 核心思路
SM4与AES的S盒均基于有限域$GF(2⁸)$的逆运算特性，通过数学方法构造仿射变换对$(T, T⁻¹)$，将SM4的S盒计算映射到AES-NI指令支持的运算流程。具体实现时将4个SM4分组(4×32bit)打包至128bit寄存器，充分利用AES-NI指令的向量化处理能力，在硬件层面实现高效并行计算。

### 关键实现细节

#### 1. 仿射变换

目的是将AES的S盒变换到SM4 S盒上

- **调整字节序** :使用`_mm_shuffle_epi8`指令对输入数据进行重新排列，使其符合SM4算法的字节序要求
  
- **线性变换** :通过手动实现的`MulMatrix`函数进行矩阵乘法运算，函数利用`_mm_shuffle_epi8`和`_mm_xor_si128`完成在有限域上的线性变换
  
- **仿射变换** :在矩阵乘法后，通过异或操作添加固定常数(0x63)，

#### 2. S盒加速

在S盒映射以后，就可以调用AES的加速指令加速

- **调用AES-NI指令** ：使用`_mm_aesenclast_si128(x, _mm_setzero_si128())`指令，直接调用AES-NI硬件加速的S盒计算
  
- **逆变换** ：在AES S盒计算完成后，再次进行仿射变换(A·T·A)，并添加SM4特定常数(0x3b)

#### 3. 并行处理优化

由于AES使用的是128bit寄存器，是SM4的四倍，单独运算效率很低，通常进行四倍并行操作

- **数据打包** ：通过`MM_PACK0_EPI32`、`MM_PACK1_EPI32`等宏将4个32bit分组高效打包至128bit寄存器
  
- **轮密钥广播** ：使用`_mm_set1_epi32(rk[i])`将当前轮密钥广播至整个128bit寄存器

### 加密流程
```c
for (int i = 0; i < 32; i++) {
    __m128i k = _mm_set1_epi32(rk[i]);  // 轮密钥加载
    Tmp[0] = MM_XOR4(X[1], X[2], X[3], k);  // 轮密钥加与非线性输入构造
    Tmp[0] = sm4_sbox(Tmp[0]);  // 使用AES-NI加速的S盒变换
    Tmp[0] = MM_XOR6(X[0], Tmp[0], MM_ROTL_EPI32(...));  // 线性扩散层
    // 更新轮状态(X[0] ← X[1], X[1] ← X[2], ...)
}