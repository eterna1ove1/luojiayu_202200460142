在SM2算法的实现参照现成的代码实现中，进一步进行性能优化，主要集中在**椭圆曲线点运算**、**数据类型转换**和**密钥派生函数（KDF）**这三个核心部分。

---

### **1. 椭圆曲线点运算的优化**
椭圆曲线密码（ECC）的核心计算是**标量乘法**（即计算 $[k]G$），这是加密/解密过程中最耗时的部分。优化手段包括：

#### **(1) 二进制展开法实现多倍点运算**
- **基础实现问题**：朴素实现会进行$k4次点加运算，时间复杂度为$O(k)$，效率极低。
- **优化方法**：采用**二进制展开法**（即快速幂思想），将$k$表示为二进制，通过倍点（Double）和点加（Add）的组合来减少计算次数。
- **原理**：例如计算 13P（13的二进制是1101）：
  
  ```
  1P → 2P (Double) → 3P (Add) → 6P (Double) → 12P (Double) → 13P (Add)
  ```
  
  原本需要13次加法，优化后仅需3次Double + 2次Add = 5次运算。
- **代码实现**：
  ```python
  def mult_point(P, k, p, a):
      Q = 0  # 无穷远点
      for bit in bin(k)[2:]:  # 遍历k的二进制位
          Q = double_point(Q, p, a)  # 每次循环先倍点
          if bit == '1':
              Q = add_point(P, Q, p, a)  # 如果当前位是1，则点加
      return Q
  ```
- **优化效果**：计算复杂度从$O(k)$降低到$O(log₂k)$，在k为大数（如256位）时，性能提升显著。

#### **(2) 更高效的模逆计算**
- **基础实现问题**：原代码使用**扩展欧几里得算法**计算模逆，涉及多次循环和临时变量交换，较慢。
- **优化方法**：直接调用Python内置的pow(x, -1, p)（Python 3.8+支持），底层采用更高效的算法（如Montgomery模乘）。
- **原理**：pow(x, -1, p)计算的是x在模p下的乘法逆元，即$x * x⁻¹ ≡ 1 (mod p)$。Python内部可能使用**快速幂+蒙哥马利约简**优化，比手写扩展欧几里得更快。
- **代码实现**：
  ```python
  def calc_inverse(M, m):
      return pow(M, -1, m)  # 直接调用内置函数
  ```
- **优化效果**：减少函数调用开销，提升模逆计算速度。

---

### **2. 数据类型转换的优化**
SM2涉及大量大整数 ↔ 字节串的转换，优化方法包括：

#### **(1) 使用`int.to_bytes()`和`int.from_bytes()`替代手动拼接**
- **基础实现问题**：原代码通过十六进制字符串中间转换（如`hex(x)[2:].rjust(k*2, '0')`），再逐字节处理，效率低。
- **优化方法**：直接使用Python的`int.to_bytes()`和`int.from_bytes()`，避免字符串操作。
- **原理**：`int.to_bytes()`直接将整数转换为指定长度的字节串，无需手动填充。`int.from_bytes()`直接解析字节串为整数，比逐字节计算更快。
- **代码实现**：
  
  ```python
  def int_to_bytes(x, k):
      return x.to_bytes(k, 'big')  # 大端序编码
  
  def bytes_to_int(M):
      return int.from_bytes(M, 'big')
  ```
- **优化效果**：减少字符串处理和循环，提升转换速度。

#### **(2) 比特串与字节串的高效转换**
- **优化方法**：使用`bin()`和`int()`直接转换，而非逐位拼接。
- **代码实现**：
  ```python
  def bytes_to_bits(M):
      return bin(int.from_bytes(M, 'big'))[2:].zfill(8*len(M))
  ```
- **优化效果**：避免逐字节处理，利用Python内置函数加速。

---



### **3. 密钥派生函数（KDF）的优化**

KDF用于从共享密钥生成加密密钥，其优化关键在**减少类型转换**和**高效拼接输入**。

#### **(1) 直接操作字节**
- **基础实现问题**：原代码在KDF中频繁拼接比特串（如`Z + int_to_bits(ct)`），导致性能瓶颈。
- **优化方法**：改为**全程字节操作**，仅在最后一步按需转换比特串。
- **原理**：SM3的输入是字节串，直接传递字节比转换到比特串更高效。计数器`ct`直接用`to_bytes(4, 'big')`拼接，避免字符串处理。
- **代码实现**：
  ```python
  def KDF(Z_bits, klen):
      Z_bytes = bits_to_bytes(Z_bits)  # 先统一转为字节
      for i in range(1, l+1):
          s = Z_bytes + i.to_bytes(4, 'big')  # 直接拼接字节
          hash_hex = sm3.sm3_hash(list(s))    # 直接哈希字节
  ```
- **优化效果**：减少中间转换，提升哈希计算速度。

#### **(2) 预计算循环次数，避免动态扩展**
- **优化方法**：根据`klen`提前计算需要的哈希轮次`l`，避免动态调整列表。
- **代码实现**：
  ```python
  l = ceil(klen / 256)  # SM3输出256位，计算所需轮次
  Ha = [None] * l      # 预分配列表
  ```
- **优化效果**：减少列表扩容开销。

---

### **总结**
| 优化方向     | 优化手段                      | 性能提升原理                    |
| ------------ | ----------------------------- | ------------------------------- |
| 椭圆曲线运算 | 二进制展开法标量乘法          | 计算复杂度从O(k)降至O(log₂k)    |
|              | 内置`pow(x,-1,p)`模逆         | 替代扩展欧几里得，减少循环      |
| 数据类型转换 | 直接使用`to_bytes/from_bytes` | 避免字符串拼接和逐字节处理      |
| KDF          | 全程字节操作                  | 减少比特串转换，直接适配SM3输入 |
| 内存管理     | 预分配列表，减少扩容          | 降低动态内存分配开销            |

这些优化使得算法在处理大数运算时更高效。

## 实现结果

![image4.png](https://github.com/eterna1ove1/luojiayu_202200460142/blob/main/images/image4.png?raw=true)