## SM3算法

SM3作为我国商用密码标准哈希算法，其设计结构属于Merkle-Damgård构造，整体流程遵循典型的迭代压缩模式。我们从算法本质特性出发，深入分析其优化可能性。

SM3算法流程可分为四个阶段：

1. **消息填充**
在原始消息末尾添加比特"1"，然后补k个"0"，使得填充后长度满足：(消息长度+1+k) ≡ 448 mod 512。最后追加64位消息长度值（大端序）。$Pad(M) = M || 1 || 0ᵏ || len(M)₆₄$

2. **分组处理**
将填充后的消息分割为512位的分组：$B⁽ⁱ⁾ = M[512i:512(i+1)]$，共n个分组

3. **消息扩展**
每个分组扩展生成132个字 ：前16个字直接取自分组,后续52个字通过迭代公式生成：$Wⱼ = P1(Wⱼ₋₁₆⊕Wⱼ₋₉⊕(Wⱼ₋₃≪15))⊕(Wⱼ₋₁₃≪7)⊕Wⱼ₋₆$，最后64个字$W'ⱼ = Wⱼ⊕Wⱼ₊₄$
4. **压缩计算**
通过64轮迭代更新8个状态变量（A-H），每轮计算SS1/SS2移位量，根据轮数选择不同的布尔函数FF/GG，更新中间值TT1/TT2，最终输出160位哈希值。

采用双重非线性函数（FF/GG）和交叉混合设计，每轮都融合前轮状态和扩展消息，形成强扩散效果。算法整体呈现雪崩效应，1比特变化可导致最终哈希值约80%比特改变。



## SM3优化

### 消息填充阶段的优化

在填充阶段，算法要求追加1比特"1"和k比特"0"，使得总长度满足(len+1+k)≡448 mod 512。这个看似简单的操作实际上可以通过预计算优化。对于流式数据，我们可以建立长度预测模型：

设原始消息长度为L比特，则填充比特数k满足：
$k = (447 - (L mod 512)) mod 512$

通过预先计算这个值，可以实现零拷贝填充。

### 消息扩展阶段的并行化

消息扩展将16个字W[0..15]扩展到68个字W[0..67]，这个过程的递推公式：
$W[j] = P1(W[j-16]⊕W[j-9]⊕(W[j-3]≪15))⊕(W[j-13]≪7)⊕W[j-6]$

其中$P1(X)=X⊕(X≪15)⊕(X≪23)$。观察发现当$j≥32$时，$W[j]$的计算仅依赖于前面已确定的W值，这形成了数据依赖链。但我们可以将扩展过程分为两个阶段：其中第一阶段$(j=16..31)$存在部分并行可能，因为$W[16..23]$只依赖$W[0..15]$，而$W[24..31]$依赖$W[8..23]$，这种部分重叠依赖关系可以通过SIMD指令并行计算多个P1函数。

### 压缩函数的关键路径

压缩函数中SS1和SS2的计算形成关键路径：
$SS1 = ((A≪12)+E+(T≪(j mod 32)))≪7$
$SS2 = SS1⊕(A≪12)$

这里存在连续的移位和加法操作，在硬件实现中会产生较长的逻辑延迟。我们可以通过预计算技术，提前计算所有可能的$T≪(j mod 32)$值（实际上只有32种可能），建立查找表。同时利用进位保存加法器(CSA)结构将三个数的加法转换为两级操作，缩短关键路径延迟。

对于布尔函数FF和GG，当j≥16时：
$FF(A,B,C) = (A∧B)∨(A∧C)∨(B∧C)$
$GG(E,F,G) = (E∧F)∨(¬E∧G)$

这些逻辑运算可以通过布尔代数重写为：
$FF(A,B,C) = (A∧B)⊕(A∧C)⊕(B∧C)$
$GG(E,F,G) = (E∧F)⊕(¬E∧G)$

这种形式更适合现代处理器的位操作指令特性。

### 迭代结构的流水线

虽然SM3的迭代结构本质上是串行的，但我们可以采用流水线技术重叠多个分组的处理。例如，当处理第i个分组时：

1. 第i-1个分组正在进行最后的压缩轮次
2. 第i个分组进行消息扩展
3. 第i+1个分组进行数据加载

这种三级流水线可以有效隐藏内存访问延迟，特别在支持乱序执行的现代处理器上效果显著。

### 数据空间局部性优化

算法中频繁访问的W和W'数组表现出良好的空间局部性。我们可以通过以下方式优化：

1. 将$W[0..67]$和$W'[0..63]$合并为一个结构体数组，提高缓存利用率
2. 对循环展开4次迭代，使每次处理的数据正好填满一个缓存行
3. 对$TT1$和$TT2$的计算采用寄存器重命名技术，减少数据冒险

### 混合精度还可以优化

SM3中的所有运算都是32位无符号整数操作，在现代64位处理器上，将两个32位W值打包到一个64位寄存器中，使用SIMD指令同时计算两个通道的P1函数：
$P1(X|Y) = (X⊕(X≪15)⊕(X≪23)) | (Y⊕(Y≪15)⊕(Y≪23))$，对$TT1/TT2$的累加采用64位中间结果，最后截断为32位

这种技术理论上可以获得近2倍的加速比.



## 代码运行结果

sm3

![image2.png](https://github.com/eterna1ove1/luojiayu_202200460142/blob/main/images/image2.png?raw=true)

sm3指令级多线程

![image3.png](https://github.com/eterna1ove1/luojiayu_202200460142/blob/main/images/image3.png?raw=true)

上面的结果符合标准加密的结果